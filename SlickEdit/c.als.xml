<profile name="/language/c/aliases">
	<p n="=surround_with_ihp">
		<text>
			if (std::is_heap(begin(%\m sur_text%), end(%\m sur_text%))) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_mme">
		<text>
			auto minmax = std::minmax_element(begin(%\m sur_text%), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_ihu">
		<text>
			auto pos = std::is_heap_until(begin(%\m sur_text%), end(%\m sur_text%));
			if (pos != end(%\m sur_text%)) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_acl">
		<text>
			auto sum = std::accumulate( begin(%\m sur_text%), end(%\m sur_text%), 0, [](int total, %\c) {
			  %\c
			} );
		</text>
	</p>
	<p n="=surround_with_eql">
		<text>
			if (std::equal(begin(%\m sur_text%), end(%\m sur_text%), begin(%\c))) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_acm">
		<text>
			auto sum = std::accumulate(begin(%\m sur_text%), end(%\m sur_text%), 0);
		</text>
	</p>
	<p n="=surround_with_ucp">
		<text>
			std::unique_copy(begin(%\m sur_text%), end(%\m sur_text%),
			  std::ostream_iterator&lt;string&gt;(std::cout, "\n"));
		</text>
	</p>
	<p n="=surround_with_ita">
		<text>
			std::iota(begin(%\m sur_text%), end(%\m sur_text%), %\c);
		</text>
	</p>
	<p n="=surround_with_iss">
		<text>
			if (std::is_sorted(begin(%\m sur_text%), end(%\m sur_text%))) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_rpc">
		<text>
			std::replace_copy(begin(%\m sur_text%), end(%\m sur_text%), begin(%\m sur_text%), %\c, %\c);
		</text>
	</p>
	<p n="=surround_with_isu">
		<text>
			auto pos = std::is_sorted_until(begin(%\m sur_text%), end(%\m sur_text%));
			if (pos != end(%\m sur_text%)) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_rmv">
		<text>
			auto pos = std::remove(begin(%\m sur_text%), end(%\m sur_text%), %\c);
			if (pos != end(%\m sur_text%)) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_nth">
		<text>
			std::nth_element(begin(%\m sur_text%), end(%\m sur_text%), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_rpi">
		<text>
			std::replace_if(begin(%\m sur_text%), end(%\m sur_text%), [](%\c) {
			%\c
			}, %\c);
		</text>
	</p>
	<p n="=surround_with_rpl">
		<text>
			std::replace(begin(%\m sur_text%), end(%\m sur_text%), %\c, %\c);
		</text>
	</p>
	<p n="=surround_with_erm">
		<text>
			%\m sur_text%.erase( std::remove( begin(%\m sur_text%), end(%\m sur_text%), %\c ), end(%\m sur_text%) );
		</text>
	</p>
	<p n="=surround_with_tfm">
		<text>
			std::transform(begin(%\m sur_text%), end(%\m sur_text%),
			  begin(%\m sur_text%), [](%\c) {
			%\c%
			} );
		</text>
	</p>
	<p n="=surround_with_fln">
		<text>
			std::fill_n(begin(%\m sur_text%), %\c, %\c );
		</text>
	</p>
	<p n="=surround_with_alo">
		<text>
			if (std::all_of(begin(%\m sur_text%), end(%\m sur_text%), [](%\c) {
			  %\c
			} ) ) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_prp">
		<text>
			if (std::prev_permutation(begin(%\m sur_text%), end(%\m sur_text%))) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_ltr">
		<text>
			%\m sur_text%.erase(0, %\m sur_text%.find_first_not_of(" \t\n\r"));
		</text>
	</p>
	<p n="=surround_with_upr">
		<text>
			std::transform(begin(%\m sur_text%), end(%\m sur_text%), begin(%\m sur_text%), [](char c) {
			return std::toupper(c);
			} );
			%\c
		</text>
	</p>
	<p n="=surround_with_psc">
		<text>
			std::partial_sort_copy(begin(%\m sur_text%), end(%\m sur_text%),
			                  begin(%\c), end(%\c));
		</text>
	</p>
	<p n="=surround_with_ppt">
		<text>
			auto pos = std::partition_point(begin(%\m sur_text%), end(%\m sur_text%), [](%\c) {
			  %\c
			} );
			if (pos != end(%\m sur_text%)) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_cnt">
		<text>
			auto n = std::count(begin(%\m sur_text%), end(%\m sur_text%), %\c);
		</text>
	</p>
	<p n="=surround_with_uqe">
		<text>
			auto pos = std::unique(begin(%\m sur_text%), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_cpy">
		<text>
			std::copy(begin(%\m sur_text%), end(%\m sur_text%), begin(%\c));
		</text>
	</p>
	<p n="=surround_with_cpb">
		<text>
			std::copy_backward(begin(%\m sur_text%), end(%\m sur_text%), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_swr">
		<text>
			swap_ranges(begin(%\m sur_text%), end(%\m sur_text%), begin(%\c));
		</text>
	</p>
	<p n="=surround_with_rtc">
		<text>
			std::rotate_copy(begin(%\m sur_text%), begin(%\c), end(%\m sur_text%),
			  begin(%\c));
		</text>
	</p>
	<p n="=surround_with_mxe">
		<text>
			auto pos = std::max_element(begin(%\m sur_text%), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_rte">
		<text>
			std::rotate(begin(%\m sur_text%), begin(%\c), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_cpi">
		<text>
			std::copy_if(begin(%\m sur_text%), end(%\m sur_text%), begin(%\c),
			[](%\c) {
        %\c
			} );
		</text>
	</p>
	<p n="=surround_with_cni">
		<text>
			auto n = std::count_if(begin(%\m sur_text%), end(%\m sur_text%), [](%\c) {
			  %\c
			});
		</text>
	</p>
	<p n="=surround_with_cpn">
		<text>
			std::copy_n(begin(%\m sur_text%), %\c, end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_srt">
		<text>
			std::sort(begin(%\m sur_text%), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_spt">
		<text>
			auto pos = std::stable_partition(begin(%\m sur_text%), end(%\m sur_text%), [](%\c) {
			  %\c});
			if (pos != end(%\m sur_text%)) {
        %\c
			}
		</text>
	</p>
	<p n="=surround_with_msm">
		<text>
			auto values = std::mismatch(begin(%\m sur_text%), end(%\m sur_text%), begin(%\m sur_text%));
			if (values.first == end(%\m sur_text%)) {
        %\c
			} else {
        %\c
			}
		</text>
	</p>
	<p n="=surround_with_mpb">
		<text>
			std::move_backward(begin(%\m sur_text%), end(%\m sur_text%), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_ptc">
		<text>
			std::partition_copy(begin(%\m sur_text%), end(%\m sur_text%),
			                  begin(%\c), end(%\c));
		</text>
	</p>
	<p n="=surround_with_pst">
		<text>
			std::partial_sort(begin(%\m sur_text%), end(%\m sur_text%), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_fnd">
		<text>
			auto pos = std::find(begin(%\m sur_text%), end(%\m sur_text%), %\c);
			if (pos != end(%\m sur_text%)) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_fre">
		<text>
			std::for_each( begin(%\m sur_text%), end(%\m sur_text%), [](%\c) {
			  %\c
			} );
		</text>
	</p>
	<p n="=surround_with_mne">
		<text>
			auto pos = std::min_element(begin(%\m sur_text%), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_fne">
		<text>
			auto pos = std::find_end(begin(%\m sur_text%), end(%\m sur_text%),
			  begin(%\c), end(%\c));
			if (pos != end(%\m sur_text%)) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_mrg">
		<text>
			std::merge(begin(%\m sur_text%), end(%\m sur_text%),
			begin(%\c), end(%\c), begin(%\c));
		</text>
	</p>
	<p n="=surround_with_srh">
		<text>
      auto pos = std::search(begin(%\m sur_text%), end(%\m sur_text%),
        egin(%\c), end(%\c));
			if (pos != end(%\m sur_text%)) {
        %\c
			}
		</text>
	</p>
	<p n="=surround_with_fni">
		<text>
			auto pos = std::find_if(begin(%\m sur_text%), end(%\m sur_text%), []( %\c ) {
			  %\c
			});
			if (pos != end(%\m sur_text%)) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_ptn">
		<text>
			auto pos = std::partition(begin(%\m sur_text%), end(%\m sur_text%), [](%\c) {
			  %\c
			});
			if (pos != end(%\m sur_text%)) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_srn">
		<text>
			auto pos = std::search_n(begin(%\m sur_text%), end(%\m sur_text%),%\c,%\c);
			if (pos != end(%\m sur_text%)) {
        %\c
			}
		</text>
	</p>
	<p n="=surround_with_ano">
		<text>
			if (std::any_of(begin(%\m sur_text%), end(%\m sur_text%), [](%\c) {
			  %\c
   	  } ) ) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_nxp">
		<text>
			if (std::next_permutation(begin(%\m sur_text%), end(%\m sur_text%))) {
        %\c
			}
		</text>
	</p>
	<p n="=surround_with_rvr">
		<text>
			std::reverse(begin(%\m sur_text%), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_rmc">
		<text>
			std::remove_copy(begin(%\m sur_text%), end(%\m sur_text%),
			  begin(%\m sur_text%), %\c);
		</text>
	</p>
	<p n="=surround_with_sts">
		<text>
			std::stable_sort(begin(%\m sur_text%), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_rmf">
		<text>
      std::remove_copy_if( begin(%\m sur_text%), end(%\m sur_text%),
        begin(%\m sur_text%), [](%\c) {
			  %\c
			} );
		</text>
	</p>
	<p n="=surround_with_rci">
		<text>
			std::replace_copy_if(begin(%\m sur_text%), end(%\m sur_text%),
			  begin(%\m sur_text%), [](%\c) {
			  %\c
			  }, %\c );
		</text>
	</p>
	<p n="=surround_with_rmi">
		<text>
			auto pos = std::remove_if( begin(%\m sur_text%), end(%\m sur_text%), [](%\c) {
			  %\c
			} );
			if (pos != end(%\m sur_text%)) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_rvc">
		<text>
			std::reverse_copy(begin(%\m sur_text%), end(%\m sur_text%), begin(%\c));
		</text>
	</p>
	<p n="=surround_with_oit">
		<text>
			std::copy( begin( %\m sur_text% ), end( %\m sur_text% ), std::ostream_iterator&lt;%\c&gt;{
			%\istd::cout, "%\c"
			} );
		</text>
	</p>
	<p n="=surround_with_sth">
		<text>
			std::sort_heap(begin(%\m sur_text%), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_phh">
		<text>
			std::push_heap(begin(%\m sur_text%), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_ffo">
		<text>
			auto pos = std::find_first_of(begin(%\m sur_text%), end(%\m sur_text%),
			  begin(%\c), end(%\c));
			if (pos != end(%\m sur_text%)) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_gnr">
		<text>
			std::generate(begin(%\m sur_text%), end(%\m sur_text%), [](%\c) {
			  %\c
			} );
		</text>
	</p>
	<p n="=surround_with_ipr">
		<text>
			if (std::is_permutation(begin(%\m sur_text%), end(%\m sur_text%), begin(%\c))) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_ipt">
		<text>
			if (std::is_partitioned(begin(%\m sur_text%), end(%\m sur_text%), [](%\c) {
			  %\c
		  } ) ) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_mkh">
		<text>
			std::make_heap(begin(%\m sur_text%), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_fil">
		<text>
			std::fill(begin(%\m sur_text%), end(%\m sur_text%), %\c);
		</text>
	</p>
	<p n="=surround_with_fin">
		<text>
			auto pos = std::find_if_not(begin(%\m sur_text%), end(%\m sur_text%),[](%\c) {
	  		%\c
			} );
			if (pos != end(%\m sur_text%)) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_lwr">
		<text>
			std::transform(begin(%\m sur_text%), end(%\m sur_text%), begin(%\m sur_text%), [](char c) {
			return std::tolower(c); } );
		</text>
	</p>
	<p n="=surround_with_lxc">
		<text>
			if (std::lexigraphical_compare(begin(%\m sur_text%), end(%\m sur_text%), 
			  begin(%\c), end(%\c)) {
			  %\c
			}
		</text>
	</p>
	<p n="=surround_with_shf">
		<text>
			std::random_shuffle(begin(%\m sur_text%), end(%\m sur_text%));
		</text>
	</p>
	<p n="=surround_with_ajf">
		<text>
			auto pos = std::adjacent_find(begin(%\m sur_text%), end(%\m sur_text%));
			if (pos != end(%\m sur_text%)) {
        %\c
			}
		</text>
	</p>
	<p n="=surround_with_trm">
		<text>
			%\m sur_text%.erase(%\m sur_text%.find_last_not_of(" \t\n\r") + 1);
		</text>
	</p>
	<p n="=surround_with_gnn">
		<text>
			std::generate_n(begin(%\m sur_text%), %\c, [](%\c) {
			  %\c
			} );
		</text>
	</p>
	<p n="=surround_with_nno">
		<text>
			if (std::none_of(begin(%\m sur_text%), end(%\m sur_text%), [](%\c) {
			  %\c
  	  } ) ) {
			  %\c
			}
		</text>
	</p>
	<p n="sti">
		<text>
			std::cin &gt;&gt; %\c
		</text>
	</p>
	<p n="sto">
		<text>
			std::cout &lt;&lt; %\c
		</text>
	</p>
	<p n="stv">
		<text>
			std::vector&lt;%\c&gt; %\c 
		</text>
	</p>
</profile>
